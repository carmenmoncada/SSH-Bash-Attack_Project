# !/usr/bin/env python3
# -*- coding: utf-8 -*-
from core.elements import *
from core.parameters import *
from core.utils import *
import random


def main():
    # Check the parameters.py file to check the constants defined
    # such as speed of light, signal power, number of connections, etc.

    label = 'snr'              # choose the label for stream method between 'snr' or 'latency'
    option = 'traffic_matrix'      # CHOOSE BETWEEN 'RANDOM' GENERATION, 'FIXED_LIST' OF CONNECTIONS or 'traffic matrix'
    connection_list = []           # List where all the connection will be saved
    # refused_requests = []        # List to save the refused requests

    # INITIALIZATION OF THE NETWORK-------------------------------------------------------------------------------------
    net = Network(file_input)   # Check in elements.py to see the root of the file
    net.connect()
    net.switching_matrix_initial()
    #net.draw()
    net.weighted_paths_dataframe(signal_power)

    # Set a seed for the random number generator
    random.seed(1)

    if option == 'traffic_matrix':
        # TRAFFIC MATRIX GENERATION ------------------------------------------------------------------------------------
        # Generating the uniform traffic matrix
        traffic_matrix = uniform_traffic_matrix_generation(net, M)
        ## IMPORTANT!
        # transceiver type is imported from elements.py, if you want to change transceiver go to that script
        plot_traffic_matrix(traffic_matrix, transceiver_type, 0, M)   # Integer number to set the title of initial matrix
        nodes_len = len(net.nodes)
        connections_completed = nodes_len * nodes_len - 1  # number of completed connection we can generate
        count_request = 0

        # while there are possible connections to satisfy, the request_generation_traffic_matrix() method is call
        while connections_completed > 0:
            # Updating the number of completed connections generated by Traffic Matrix
            connections_completed -= net.request_generation_traffic_matrix(traffic_matrix, connection_list,
                                                                           signal_power, label, count_request)

        # traffic matrix after streaming all the requests
        plot_traffic_matrix(traffic_matrix, transceiver_type, 1, M)

        # Calling best_metric function to print the best snr, latency and bit rate for all the paths
        best_snr, best_latency, best_bit_rate = print_best_metrics(connection_list, net)

        # Converting the snr, latency and bit rates into arrays
        snr_array = [-5 if value is None else value for value in best_snr]
        rejected_con = snr_array.count(-5)
        snr_array = np.array(snr_array)

        # If the connection is refused, the flag = -1 is set
        late_array = [-0.01 if value is 0 else value for value in best_latency]
        latency_array = np.array(late_array)
        # Average SNR and Latency
        avg_latency, avg_snr = average_parameter(latency_array, snr_array)

        # Computing the capacity and average bit rate
        # and plotting them in the graph for the SNR, Latency and Bit Rate of each connection
        bit_rate_array = np.array(best_bit_rate)
        total_capacity, average_bit_rate, max_capacity, min_capacity = total_avg_max_min_capacity(bit_rate_array)
        plots(latency_array, snr_array, bit_rate_array, average_bit_rate, total_capacity, max_capacity, min_capacity,
              transceiver_type, rejected_con, avg_latency, avg_snr, M)
        print('\n')
        print('For a single Markov Chain we obtained:')
        print('Average Bit Rate :', average_bit_rate, 'Gpbs')
        print('Average SNR :', avg_snr, 'dB')
        print('Average Latency :', avg_latency, 's')
        print('Total Capacity :', total_capacity, 'Gbps')
        print('Maximum Capacity:', max_capacity, 'Gbps')
        print('Minimum Capacity:', min_capacity, 'Gbps')

    else:
        # Generate connections according to the function chose by the user (Random List, saved List)
        # it will return a list with 100 connections streamed
        connection_list = generating_connections(option, connection_list, net, signal_power, label)

        # Calling best_metric function to print the best snr, latency and bit rate for all the paths
        best_snr, best_latency, best_bit_rate = print_best_metrics(connection_list, net)

        # Converting into arrays the snr, latency and bit rates
        # If the connection is rejected bit rate will be set with the Flag -5
        snr_array = [-5 if value is None else value for value in best_snr]
        rejected_con = snr_array.count(-5)
        snr_array = np.array(snr_array)

        # If the connection is refused, the flag = -1 is set
        late_array = [-0.01 if value is 0 else value for value in best_latency]
        latency_array = np.array(late_array)

        avg_latency, avg_snr = average_parameter(latency_array,snr_array)

        # Computing the capacity and average bit rate
        # and plotting them in the graph for the SNR, Latency and Bit Rate of each connection
        bit_rate_array = np.array(best_bit_rate)
        total_capacity, average_bit_rate, max_capacity, min_capacity = total_avg_max_min_capacity(bit_rate_array)

        plots(latency_array, snr_array, bit_rate_array, average_bit_rate, total_capacity, max_capacity, min_capacity,
              transceiver_type, rejected_con, avg_latency, avg_snr, M)

        print('\n')
        print('For a single Markov Chain we obtained:')
        print('Average Bit Rate :', average_bit_rate, 'Gpbs')
        print('Average SNR :', avg_snr, 'dB')
        print('Average Latency :', avg_latency, 's')
        print('Total Capacity :', total_capacity, 'Gbps')
        print('Maximum Capacity:', max_capacity, 'Gbps')
        print('Minimum Capacity:', min_capacity, 'Gbps')

    #capacity_vs_m(transceiver)

if __name__ == '__main__':
    main()
