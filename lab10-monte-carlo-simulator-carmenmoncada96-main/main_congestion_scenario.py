# !/usr/bin/env python3
# -*- coding: utf-8 -*-
import pandas as pd
from core.elements import *
from core.parameters import *
from core.utils import *

# ESTABLISH THE NUMBER OF MC RUNS YOU WANT TO PERFORM
MC = 11

def main():
    # Check the parameters.py file to check the constants defined
    # such as speed of light, signal power, number of connections, etc.

    label = 'latency'              # choose the label for stream method between 'snr' or 'latency'
    option = 'traffic_matrix'      # choose between 'random' generation, 'fixed_list' of connections or 'traffic matrix'
    # refused_requests = []        # List to save the refused requests

    list_average_SNR_db = []
    list_average_latency = []
    list_average_bit_rate = []
    list_max_capacity = []
    list_min_capacity = []
    list_total_capacity = []
    list_blocking_events = []
    list_max_gsnr = []
    list_min_gsnr = []
    list_rejected_connections = []
    list_succesful_connections = []

    # list created to compute per-link capacity
    list_paths = []
    list_bit_rate_list = []

    #for M in range(1,2):   # Change M in parameter.py, this loop it is just to iterate through each MC=5, using
                            # the same value for M
    for markov_chain in range(1,MC):

        connection_list = []  # List where all the connection will be saved

        # INITIALIZATION OF THE NETWORK----------------------------------------------------------------------------
        net = Network(file_input)   # Check in elements.py to see the root of the file
        net.connect()
        # net.draw()
        net.weighted_paths_dataframe(signal_power)

        # Set a seed for the random number generator
        #random.seed()

        if option == 'traffic_matrix':
            # TRAFFIC MATRIX GENERATION ---------------------------------------------------------------------------
            # Generating the uniform traffic matrix
            traffic_matrix = uniform_traffic_matrix_generation(net, M)
            # IMPORTANT!
            # transceiver type is imported from elements.py, if you want to change Transceiver go to that script
            # Int: set the title of initial matrix
            plot_traffic_matrix(traffic_matrix, transceiver_type, 0, M, markov_chain)
            nodes_len = len(net.nodes)
            # Number of completed connections we can generate by the traffic matrix
            # Completed connections != accepted connections
            total_connections_number = nodes_len * nodes_len - nodes_len
            no_request = 0                   # NUMBER OF REQUEST CONNECTIONS COUNTER
            blocking_nro = 0                 # NUMBER OF BLOCKING CONNECTIONS
            count_request = 0                # AUXILIAR VARIABLES TO SAVE INFORMATION
            blocking_events = 0


            # while there are still possible connections to satisfy, the request_generation_traffic_matrix() method
            # is call
            while total_connections_number > 0:
                # Updating the number of completed connections generated by Traffic Matrix, and updating the
                # counter for accepted connections and blocking events
                connections_completed, count_req, blocking_count = net.request_generation_traffic_matrix(traffic_matrix,
                                                                                       connection_list,
                                                                                       signal_power,
                                                                                       label,
                                                                                       no_request,
                                                                                       blocking_nro)
                total_connections_number -= connections_completed
                count_request += count_req
                blocking_events += blocking_count
                if total_connections_number <= 1:
                    break

            # Plot traffic matrix AFTER streaming all the requests
            plot_traffic_matrix(traffic_matrix, transceiver_type, 1, M, markov_chain)

            # Calling best_metric function to print the best snr (LINEAR), latency and bit rate for all the paths
            best_snr, best_latency, best_bit_rate, path_bit_rate = print_best_metrics(connection_list, net)

            # Converting the snr, latency and bit rates into arrays
            snr_array_db = [-5 if value is None else value for value in best_snr]
            rejected_con = snr_array_db.count(-5)
            snr_array_db = np.array(snr_array_db)

            # If the connection is refused, the flag = -1 is set
            late_array = [-0.01 if value is None or value == 0 else value for value in best_latency]
            latency_array = np.array(late_array)
            # Average SNR and Latency
            avg_latency, avg_snr_db = average_parameter(latency_array, snr_array_db)

            # Computing the capacity and average bit rate
            # and plotting them in the graph for the SNR, Latency and Bit Rate of each connection
            bit_rate_array = np.array(best_bit_rate)
            total_capacity, average_bit_rate, max_capacity, min_capacity, max_gsnr, \
            min_gsnr = total_avg_max_min_capacity(bit_rate_array, snr_array_db)

            list_average_SNR_db.append(avg_snr_db)
            list_average_latency.append(avg_latency)
            list_average_bit_rate.append(average_bit_rate)
            list_max_capacity.append(max_capacity)
            list_min_capacity.append(min_capacity)
            list_total_capacity.append(total_capacity)
            list_blocking_events.append(blocking_events)
            list_max_gsnr.append(max_gsnr)     # GSNR = SNR
            list_min_gsnr.append(min_gsnr)
            list_rejected_connections.append(sum(1 for x in snr_array_db if x < 0))
            list_succesful_connections.append(sum(1 for x in snr_array_db if x > 0))

            list_paths.append(path_bit_rate)
            list_bit_rate_list.append(best_bit_rate)

            # Uncomment the line according the type of transceiver
            # list_shannon_avg_capacity.append(np.mean(list_average_capacity))
            # list_fixed_avg_capacity.append(np.mean(list_average_bit_rate))
            # list_flex_avg_capacity.append(np.mean(list_average_bit_rate))

            plots(latency_array, snr_array_db, bit_rate_array, average_bit_rate, total_capacity, max_capacity,
                  min_capacity, transceiver_type, rejected_con, avg_latency, avg_snr_db, M, count_request)
            print('\n \n --------------- END OF THE RUNNING  -------------------------- ')

    print('\n')
    # Clearing variables before next MC cycle
    # best_snr = ''
    # best_latency = ''
    # best_bit_rate = ''
    # avg_latency = ''
    # avg_snr_db = ''
    # total_capacity = ''
    # average_bit_rate = ''
    # max_capacity = ''
    # min_capacity = ''
    # blocking_events = ''
    # count_request = ''
    # rejected_con = ''
    # snr_array_db = ''
    # late_array = ''
    # latency_array = ''
    # bit_rate_array = ''
    print()

    # FOR POST -PROCESSING PURPOSES
    # Route to save csv file
    file_name_data = f'MC_{M}_{transceiver_type}.csv'
    file_name_data_1 = f'MC_{M}_lines_{transceiver_type}.csv'
    csv_file = csv_route_space/file_name_data
    csv_file_11 = csv_route_space/file_name_data_1
    index = ['SNR', 'Latency', 'Average_capacity', 'Max_capacity', 'Min_capacity', 'Total_capacity', 'Blocking_event',
             'Max_snr', 'Min_snr', 'Rejected_connections', 'Accepted_connections']
    # Columns represent the results corresponding to each MC -------->> BE AWARE OF THIS WHEN CHANGE THE NUMBER OF MC
    columns = [str(i) for i in range(1, MC)]
    df_data = pd.DataFrame(columns = columns, index=index)

    df_data.loc['SNR'] = list_average_SNR_db
    df_data.loc['Latency'] = list_average_latency
    df_data.loc['Average_capacity'] = list_average_bit_rate
    df_data.loc['Max_capacity'] = list_max_capacity      # Max bit rate
    df_data.loc['Min_capacity'] = list_min_capacity      # Min bit rate
    df_data.loc['Total_capacity'] = list_total_capacity
    df_data.loc['Blocking_event'] = list_blocking_events
    df_data.loc['Max_snr'] = list_max_gsnr
    df_data.loc['Min_snr'] = list_min_gsnr
    df_data.loc['Rejected_connections'] = list_rejected_connections
    df_data.loc['Accepted_connections'] = list_succesful_connections
    df_data.to_csv(csv_file, index=True)

    columns = ['paths', 'bit_rate']
    df_links = pd.DataFrame({
    'paths': list_paths,
    'bit_rate': list_bit_rate_list})
    df_links.to_csv(csv_file_11, index=False)

if __name__ == '__main__':
    main()
